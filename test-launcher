#!/usr/bin/env bash
set -o errexit
[[ $DEBUG ]] && set -x



help_doc() {
	cat 1>&2 <<-'HelpDoc'

		test-launcher [OPTION]... [FILE]... [DIRECTORY]...

		Each DIRECTORY is assumed to only contain test files intended to be executed.
		FILE and DIRECTORY is validated before execution.

		Null characters are allowed in stdout and stderr of tests. Also in stdin --fork-stdin.

		OPTIONs:
		  -a|--all         Include files and directories beginning with '.'
		  -q|--quiet       only script errors, tests and --help will print to stdout or stderr
		  -r|--recursive   search each DIRECTORY recursively

		  --print-result   (always|failure|success|never)
		  --print-stdout   (always|failure|success|never)
		  --print-stderr   (always|failure|success|never)

		  --fork-stdin     Write stdin to a temp file and pipe into all tests


		  # -h and -i are cumulative and overwrite each other
		  -o|--halt-on     (failed_test|missing_test|non_exec|no_tests)
		  -i|--ignore      (failed_test|missing_test|non_exec|no_tests)


		Defaults:
		  --print-result always
		  --print-stdout never
		  --print-stderr failure
		  --halt-on missing_test
		  --halt-on failed_test
		  --ignore non_exec
		  --ignore no_tests


		Exit status:
		  0    OK
		  1    unmanaged error
		  2    failed parameter validation
		  4    failed validation of test files before execution
		  8    one or more tests returned an exit code greater than 0

	HelpDoc
	[[ $1 ]] && exit "$1"
}
[[ $1 ]] || help_doc 0



# Apply defaults
declare -A halt_on=(
	['missing_test']=1
	['failed_test']=1
)
print_result='always'
print_stdout='never'
print_stderr='failure'
tmp_dir_root='/tmp'
fork_stdin=
recursive=
quiet=



print_stderr() {
	if [[ $1 == '0' ]]; then
		[[ $2 ]] && [[ ! $quiet ]] && printf "$2" "${@:3}" 1>&2 || :
	else
		[[ $2 ]] && printf '%s'"$2" "ERROR: ${0##*/}, " "${@:3}" 1>&2 || :
		exit "$1"
	fi
}


# Read params
test_paths=()
while [[ $1 ]]; do
	case $1 in
		'--all'|'-a')
            shopt -s dotglob ;;
		'--print-result')
			shift; print_result=$1 ;;
		'--print-stdout')
			shift; print_stdout=$1 ;;
		'--print-stderr')
			shift; print_stderr=$1 ;;
		'--halt-on'|'-o')
			shift; halt_on["$1"]=1 ;;
		'--ignore'|'-i')
			shift; halt_on["$1"]= ;;
		'--recursive'|'-r')
			recursive=1 ;;
		'--fork-stdin')
			fork_stdin=1 ;;
		'--quiet'|'-q')
			quiet=1 ;;
		'--help'|'-h')
			help_doc 0 ;;
		'--')
			break ;;
		'-'*)
			print_stderr 2 '%s\n' 'unrecognized parameter: '"$1" ;;
		*)
			test_paths+=("$1") ;;
	esac
	shift
done
test_paths+=("$@")



# Validate parameter values
[[ ${#test_files[@]} ]] || help_doc 2
[[ -d $tmp_dir_root ]] || printf '%s\n' 'temp directory doesnt exist: '"$tmp_dir_root"

re='^(always|failure|success|never)$'
[[ $print_result =~ $re ]] || print_stderr 2 '%s\n' 'unrecognized value for --print-result: '"$print_result"
[[ $print_stdout =~ $re ]] || print_stderr 2 '%s\n' 'unrecognized value for --print-stdout: '"$print_stdout"
[[ $print_stderr =~ $re ]] || print_stderr 2 '%s\n' 'unrecognized value for --print-stderr: '"$print_stderr"



# Manage/create temp working directory for buffering the stdin and stderr of tests
umask 0077
tmp_dir=$tmp_dir_root'/test-launcher__'$$
[[ -d $tmp_dir ]] && rm -rf "$tmp_dir"
on_exit() {
	[[ -d $tmp_dir ]] && rm -rf "$tmp_dir"
}
trap on_exit EXIT
mkdir "$tmp_dir"



# Validate paths giving as parameters and put the filepaths to execute into "test_files" array
shopt -s nullglob globstar
test_files=()
for test_path in "${test_paths[@]}"; do
	if [[ -x $test_path ]]; then

		if [[ -d $test_path ]]; then
			[[ $recursive ]] && paths_tmp_arr=("$test_path/"**) || paths_tmp_arr=("$test_path/"*)
			for test_path_sub in "${paths_tmp_arr[@]}"; do
				[[ -x $test_path_sub ]] && [[ -f $test_path_sub ]] && test_files+=("$test_path_sub")
			done
		else
			test_files+=("$test_path")
		fi
		continue

	fi

	[[ ${halt_on['missing_test']} ]] && [[ ! -e $test_path ]] && print_stderr 4 '%s\n' 'test path does not exist: '"$test_path"
	[[ ${halt_on['non_exec']} ]] && print_stderr 4 '%s\n' 'test path is not executable: '"$test_path"
done
[[ ${halt_on['no_tests']} ]] && [[ ${#test_files[@]} == '0' ]] && print_stderr 4 '%s\n' 'no files to execute'




# Write stdin to a file
[[ $fork_stdin ]] && cat /dev/fd/0 > "$tmp_dir"'/stdin'




# Declare functions for printing success/failure conditions of tests
print_success() {
	[[ $print_stdout == 'always' || $print_stdout == 'success' ]] && cat "$tmp_dir"'/stdout'
	[[ $print_stderr == 'always' || $print_stderr == 'success' ]] && cat "$tmp_dir"'/stderr' 1>&2
	print_stderr 0 '\e[32m%s\e[0m %s\n' "[${exit_code}]" "${test_path@Q}"
}

print_failure() {
	[[ $print_stdout == 'always' || $print_stdout == 'failure' ]] && cat "$tmp_dir"'/stdout'
	[[ $print_stderr == 'always' || $print_stderr == 'failure' ]] && cat "$tmp_dir"'/stderr' 1>&2
	print_stderr 0 '\e[31m%s\e[0m %s\n' "[${exit_code}]" "${test_path@Q}"
}



# Execute filepaths stored in the "test_files" array as tests
test_failed=
for test_path in "${test_files[@]}"; do
	if [[ $fork_stdin ]]; then
		cat "$tmp_dir"'/stdin' | "$test_path" 1> "$tmp_dir"'/stdout' 2> "$tmp_dir"'/stderr'
	else
		/bin/sh "$test_path" 1> "$tmp_dir"'/stdout' 2> "$tmp_dir"'/stderr'
	fi
	exit_code=$?

	case $print_result in
		'always'|'success')
			[[ $exit_code == '0' ]] && print_success
			;;&
		'always'|'failure')
			[[ $exit_code == '0' ]] || print_failure
			;;
	esac

	if [[ $exit_code != '0' ]]; then
		[[ ${halt_on['failed_test']} ]] && exit 8
		test_failed=1
	fi
done



[[ $test_failed ]] && exit 8
exit 0




